Game-Of-LiveKindaWorking_V2_12.779MS                                                                                    PAGE 1
                         1     ;--------------------Game of live - --------------------
                         2     ;
                         3     ; Vorlesung:    Systemname Programmierung
                         4     ; Von:          Jennifer, Thomas und Alexander
                         5     ; https://de.wikipedia.org/wiki/Conways_Spiel_des_Lebens
                         6     ;
                         7     ;---Fakten---
                         8     ; Zeilen:
                         9     ; Dauer New_Generation: 12,779ms
                        10
                        11     ; -----------------
                        12     ; Startpunkt
                        13     ;------------------
                        14     cseg at 0h
0000 0150               15     ajmp init       ;Überspringe interrupts und gehe zur initialisierung
                        16     cseg at 100h
                        17
                        18     ; -----------------
                        19     ; Interrupt Timer 0
                        20     ;------------------
                        21     ORG 0bh         ;Einsprung Adresse für TF0
****WARNING:ThisORGhaslowervaluethanthepreviousone
000B 120075             22     call setTimer0  ;Setzen des Startwertes von Timer0 (Da 16Bit kein automatischer reload!)
000E 120087             23     call timer0Routine;Springe zur routine für Timer0
0011 32                 24     reti            ;Springe zur Stelle im Code vor dem Interrupt
                        25
                        26     ; -----------------
                        27     ; Interrupt timer 1
                        28     ;------------------
                        29     ORG 1bh
001B 12007E             30     call setTimer1  ;Setzen des Startwertes von Timer1 (Da 16Bit kein automatischer reload!)
001E 75280F             31     MOV 40,#0fh;    ;Setze Speicher an Stelle 40 auf #0Fh (TODO Richtiger Merker wäre besser)
0021 32                 32     reti            ;Springe zur Stelle im Code vor dem Interrupt
                        33
                        34     ;------------------
                        35     ;init
                        36     ;------------------
                        37     ORG 50h
                        38     init:
0050 1201AB             39     call initCanvas
                        40
0053 75A88A             41     mov IE, #10001010b      ;Setze EA, ET0, ET1 um die Timer einzustellen
0056 758911             42     mov tmod, #00010001b    ;Setze timer modus für T0 und T1 auf 16Bit
                        43
0059 120075             44     call setTimer0          ;Setze Startwerte für T0
005C D28C               45     SETB TR0                ;Starte T0
005E 12007E             46     call setTimer1          ;Setze Startwerte für T1
0061 D28E               47     SETB TR1                ;Starte T1
                        48
0063 120155             49     call display
                        50
0066 120069             51     call main
                        52
                        53     ;------------------
                        54     ;main (loop)
                        55     ;------------------
                        56     main:
0069 E528               57     MOV A,40                ;Lade byte welches von T1 gesetzt wird in Akku
006B 60FC               58     JZ main                 ;Wenn es null versuche es nochmal
006D 752800             59     MOV 40,#0               ;Sonst setze es auf null...
0070 120093             60     call NEW_GENERATION     ;...und berechne die neue Generation
0073 80F4               61     jmp main                ;Danach wieder von vorne
                        62
                        63     ;------------------
                        64     ;Rücksetzten der Timer
                        65     ;------------------
                        66     setTimer0:
0075 758A00             67     mov tl0, #000h          ;Setzen des niederwertigen start bytes von T0
0078 758CFD             68     mov th0, #0fdh          ;Setzen des höherwertigen start bytes von T0
007B D28C               69     SETB TR0                ;Starte Timer 0
007D 22                 70     ret
                        71
                        72     setTimer1:
007E 758B68             73     mov tl1, #068h          ;Setzen des niederwertigen start bytes von T1
0081 758DC5             74     mov th1, #0C5h          ;Setzen des höherwertigen start bytes von T1
0084 D28E               75     SETB TR1                ;Starte Timer 1
0086 22                 76     ret
                        77
                        78     ;----------------------
                        79     ; timer0 inerrupt routine
                        80     ;----------------------
                        81     timer0Routine:
0087 C000               82     push 00h                ;Speichern von R0 auf dem Stack, damit dieser nach der Interrupt routine wied
0089 C0E0               83     push ACC                ;Das gleiche für den Akku
008B 120155             84     call display            ;Einmal das Spielfeld zeichnen
008E D0E0               85     pop ACC                 ;Rücksetzten von A aus dem Stack
0090 D000               86     pop 00h                 ;Das gleiche für R0
0092 22                 87     ret
                        88
                        89     ;----------------------
                        90     ; Logik für die neue Generation
                        91     ;----------------------
                        92     new_generation:
0093 7A00               93     MOV R2,#0               ;Zeilen Zähler (0-7)
                        94
                        95     checkrow:               ;Iteriert durch alle Zeilen
0095 7B00               96     MOV R3,#0               ;Spalten Zähler (0-7)
0097 7C00               97     MOV R4,#0               ;R4 ist ein Zwischenspeicher für die neue Zeile
0099 7900               98     MOV R1,#0               ;TODO
                        99
                       100     checkcolumn:            ;Iteriert durch alle Spalten
009B 7F00              101     MOV R7,#0               ;Zurücksetzen von R7 (Speichert die anzahl an Nachbarn einer Zelle zwischen)
009D 9001D7            102     mov DPTR,#table2        ;Laden der Masken für die Nachbar-Checks
00A0 11DF              103     ACALL checkTop          ;Überprüfen wie viele Nachbarn in der Zeile oberhalb der Zelle sind
00A2 11EA              104     ACALL checkMid          ;Überprüfen wie viele Nachbarn in der Zeile der Zelle sind
00A4 11EF              105     ACALL checkBottom       ;Überprüfen wie viele Nachbarn in der Zeile unterhalb der Zelle sind
                       106
00A6 9001CF            107     mov DPTR,#table         ;Setze DataPointer auf masken tabelle für das hinzufügen der neuen Zelle
00A9 EB                108     mov A,R3                ;Lade die aktuelle Spaltennummer
00AA 93                109     movC A,@A+DPTR          ;Hole Maske dass nur die Spalte gesetzt wird (z.B. Maske Spalte 0: #10000000b
00AB FE                110     mov R6,A;               ;Zwischenspeichern des Maske in R6
                       111
00AC EA                112     MOV A,R2;               ;Kopiere aktuelle Zeile der Zelle in R0
00AD F8                113     MOV R0,A;
00AE E2                114     MOVX A,@R0;             ;Lade Zeileninhalt aus Speicher
00AF FD                115     MOV R5,A;               ;Zwischenspeichern der Zeile in R5
                       116
00B0 EF                117     MOV A,R7;               ;Hole die Anzahl an Nachbarn in den Akku zum vergleichen
00B1 B40207            118     CJNE A,#2,checkUnderPopulation;Überprüfe ob es zwei Nachbarn sind, wenn nicht dann ob mehr oder wenig
00B4 EE                119     MOV A,R6                ;Wenn A = 2 -> Behalte Wert der Zelle bei und lade die in R6 zwischengespeich
00B5 5D                120     ANL A,R5                ;Maskiere Wert der Zelle aus
00B6 49                121     ORL A,R1                ;Und füge ihn zur neuen Zeile hinzu
00B7 F9                122     MOV R1,A                ;Speichere den Wert der aktualisierten, neuen Zeile zwischen
00B8 0200CB            123     JMP checkEnd            ;Die Überprüfung der Zelle ist zu Ende
                       124
                       125     checkUnderPopulation:   ;Überprüfe ob eine Unterpopulation vorliegt und die Zelle an Einsamkeit stirb
00BB 5003              126     JNC checkPerfectPopulation;Wenn A > 2, dann wurde das Carry bit durch CJNE auf 0 gesetzt -> Sprung zu
00BD 0200CB            127     JMP checkEnd            ;Sonst war es eine Unterpopulation und die Zelle stirbt (Wird nicht gesetzt)
                       128
                       129     checkPerfectPopulation: ;Überprüfe ob es genau 3 Nachbarn gibt und die Zelle reanimiert wird
00C0 B40308            130     CJNE A,#3,checkEnd      ;Wenn A != 3 können es jetzt nur noch mehr sein -> Zelle stirbt (wird nicht g
00C3 EE                131     MOV A,R6                ;Lade die in R6 gespeicherte Maske
00C4 54FF              132     ANL A,#11111111b        ;Setze die Zelle durch die Maske an der entsprechenden Stelle auf 1
00C6 49                133     ORL A,R1                ;Berechne neue Zeile
00C7 F9                134     MOV R1,A                ;Füge Wert zur neuen Zeile hinzu
00C8 0200CB            135     JMP checkEnd            ;Die Überprüfung endet hier
                       136
                       137     checkEnd:               ;Sprungpunkt wenn die Überprüfungen enden
00CB 0B                138     INC R3                  ;Die Nächste Spalte wird betrachtet
00CC EB                139     MOV A,R3                ;Lade Spalten Nr. in Akku zum Vergleichen
00CD B408CB            140     CJNE A,#8,checkcolumn   ;Wenn die Spalten Nr. 8 entspricht wurde die komplette Zeile bearbeitet und e
                       141
                       142
00D0 EA                143     MOV A,R2;               ;Stattdessen wird der Zeilenzähler zum Vergleichen in den Akku geladen
00D1 2464              144     ADD A,#100;             ;Und es wird 100 dazu addiert (Um sicherzugehen dass keine schon belegte Spei
00D3 F8                145     MOV R0,A;               ;Die Speicherstellen Adresse wird in R0 geschrieben
00D4 E9                146     MOV A,R1;               ;Und der zu speichernde Inhalt (die neue Zeile) in den Akku kopiert
00D5 F2                147     MOVX @R0,A;             ;Anschließend wird die Zeile in den Speicher geschreiben
                       148
00D6 0A                149     INC R2                  ;Die Zeilen Nr. um ein erhöht
00D7 EA                150     MOV A,R2                ;und zu Vergleichszwecken un den Akku geschrieben
00D8 B408BA            151     CJNE A,#8,checkrow      ;Wenn die Zeilen Nr. 8 entspricht wurden alle Zeilen bearbeitet und die neue
                       152
00DB 120124            153     call copyNewGenerationToField;Die neue Generation wird nun vom Zwischenspeicher auf das richtige Feld
00DE 22                154     ret                     ;Fertig, kehre zur Hauptschleife "main" zurück
                       155
                       156     ;----------------------
                       157     ; Logik zum ermitteln der Anzahl an Nachbarn in der selben Zeile, der oberhalb und der unterhalb der
                       158     ;----------------------
                       159     checkTop:
00DF EA                160     MOV A,R2                ;Lade Zeilen Nr.
00E0 7807              161     MOV R0,#7;              ;Wenn Zeilen Nr. = 0 ist die unterstee Zeile die "darüber", da das Spielfel
00E2 6002              162     JZ gotTopRow            ;Falls Zeilen Nr. = 0 springe zu "gotTopRow" da keine weitere berechnung nö
00E4 14                163     DEC A;                  ;Falls nicht entspricht die Zeilen Nr. darüber der Nr. im Akku - 1
00E5 F8                164     MOV R0,A;               ;Speichern der Zeilen Nr. in R5
                       165
                       166     gotTopRow:
00E6 1200FE            167     CALL calculateNeighbours;Berechne die Nachbarn für die Zeile
00E9 22                168     ret                     ;Fertig
                       169
                       170     checkMid:
00EA EA                171     MOV A,R2;               ;Lade Zeilen Nr.
00EB F8                172     MOV R0,A;               ;Speicher Zeilen Nr. in R5 zwischen
00EC 3107              173     ACALL calculateMiddleNeighbours;Berechne die Nachbarn für die Mittlere Zeile (Eigene Zelle wird nicht
00EE 22                174     ret
                       175
                       176     checkBottom:
00EF EA                177     MOV A,R2;               ;Lade Zeilen Nr.
00F0 7800              178     MOV R0,#0;              ;Wenn Zeilen Nr. = 7 ist die oberste Zeile die darunter, da das Spielfeld sph
00F2 B40703            179     CJNE A,#7,getBottomRow
00F5 0200FA            180     JMP gotBottomrow        ;Wenn die Zeilen Nr. = 7 muss nichts mehr getan werden
                       181     getBottomRow:
00F8 04                182     INC A;                  ;Wenn sie != 7 dann ist die untere Zeilen Nr. A - 1
00F9 F8                183     MOV R0,A;               ;Speichern der Unteren Zeilen Nr. in R5
                       184     gotBottomRow:
00FA 1200FE            185     CALL calculateNeighbours;Berechne die Nachbarn für die Zeile
00FD 22                186     ret
                       187
                       188     calculateNeighbours:
                       189     ;MOV A,R5               ;Laden der Zeilen Nr.
                       190     ;MOV R0,A
                       191
00FE E2                192     MOVX A,@R0;             ;Laden der entsprechenden Zeile
00FF FE                193     MOV R6,A                ;Speichern der rotierten Zeile
                       194
0100 12010D            195     call checkSideNeighbours;Ermitteln ob die Seitlichen Nachbarn gesetzt sind
0103 120118            196     call checkMiddleNeighbour;Ermitteln ob mittlerer Nachbar gesetzt ist
                       197
                       198     ;MOV R6,#0              ;Zurücksetzten von R6
0106 22                199     ret
                       200
                       201     calculateMiddleNeighbours:
                       202     ;MOV A,R5;
                       203     ;MOV R0,A;
0107 E2                204     MOVX A,@R0;             ;Laden der entsprechenden Zeile
0108 FE                205     MOV R6,A                ;Speichern der rotierten Zeile
                       206
0109 12010D            207     call checkSideNeighbours;Ermitteln ob die Seitlichen Nachbarn gesetzt sind
                       208
                       209     ;MOV R6,#0              ;Zurücksetzten von R6
010C 22                210     ret
                       211
                       212
                       213     ;----------------------
                       214     ; Logik zum ermitteln der Nachbarn Rechts, Links und in der selben Spalte einer Zelle
                       215     ;----------------------
                       216     checkSideNeighbours:
010D EB                217     MOV A,R3                ;Lade Spalten Nr. in R3
010E 12011E            218     call incIfSet           ;Wenn die Spalte A der Zeile gesetzt ist wird R7 erhöht
                       219
0111 EB                220     MOV A,R3                ;Lade Spalten Nr. in R3
0112 2402              221     ADD A,#2                ;Erhöhe Spalten Nr. um zwei um den rechten Nachbarn auszumaskieren
0114 12011E            222     call incIfSet           ;Wenn die Spalte A der Zeile gesetzt ist wird R7 erhöht
0117 22                223     ret                     ;Fertig -> Rücksprung
                       224
                       225     checkMiddleNeighbour:
0118 EB                226     MOV A,R3                ;Lade Spalten Nr. in R3
0119 04                227     INC A                   ;Erhöhe Spalten Nr. um eins um den mittleren Nachbarn auszumaskieren
011A 12011E            228     call incIfSet           ;Wenn die Spalte A der Zeile gesetzt ist wird R7 erhöht
011D 22                229     ret                     ;Fertig -> Rücksprung
                       230
                       231     incIfSet:
011E 93                232     MOVC A,@A+DPTR          ;Lade Maske für die Spalte A
011F 5E                233     ANL A,R6;               ;Ermittel den Zustand der Spalte mithilfe der Zeile R6
0120 6001              234     JZ rightcheckdone       ;Wenn A = 0 war die Zelle nicht gesezt und das erhöhen des Nachbar Zählers wi
0122 0F                235     INC R7;                 ;Sonst: Erhöhen des Nachbarzählers
                       236     rightCheckDone:
0123 22                237     ret                     ;Fertig -> Rücksprung
                       238
                       239     ;----------------------
                       240     ; Kopieren der neuen Generation auf die Speicherstellen welche welche gezeichnet werden
                       241     ;----------------------
                       242     copyNewGenerationToField:
0124 7864              243     MOV R0,#100
0126 7900              244     MOV R1,#0
0128 E2                245     MOVX A,@R0
0129 F3                246     MOVX @R1,A
                       247
012A 7865              248     MOV R0,#101
012C 7901              249     MOV R1,#1
012E E2                250     MOVX A,@R0
012F F3                251     MOVX @R1,A
                       252
0130 7866              253     MOV R0,#102
0132 7902              254     MOV R1,#2
0134 E2                255     MOVX A,@R0
0135 F3                256     MOVX @R1,A
                       257
0136 7867              258     MOV R0,#103
0138 7903              259     MOV R1,#3
013A E2                260     MOVX A,@R0
013B F3                261     MOVX @R1,A
                       262
013C 7868              263     MOV R0,#104
013E 7904              264     MOV R1,#4
0140 E2                265     MOVX A,@R0
0141 F3                266     MOVX @R1,A
                       267
0142 7869              268     MOV R0,#105
0144 7905              269     MOV R1,#5
0146 E2                270     MOVX A,@R0
0147 F3                271     MOVX @R1,A
                       272
0148 786A              273     MOV R0,#106
014A 7906              274     MOV R1,#6
014C E2                275     MOVX A,@R0
014D F3                276     MOVX @R1,A
                       277
014E 786B              278     MOV R0,#107
0150 7907              279     MOV R1,#7
0152 E2                280     MOVX A,@R0
0153 F3                281     MOVX @R1,A
                       282
0154 22                283     ret
                       284
                       285     ;----------------------
                       286     ; Zeichen der Speicher stelle 0h bis 7h auf die LED-Matrix
                       287     ;----------------------
                       288     display:
0155 F52A              289     mov 42,A
                       290
0157 7800              291     mov R0,#0h
0159 E2                292     movx A,@R0
015A 75B001            293     mov P3, #00000001b
015D F5A0              294     mov P2, a
015F 75A000            295     mov P2,#0
                       296
0162 08                297     inc R0
0163 E2                298     movx A,@R0
0164 75B002            299     mov P3, #00000010b
0167 F5A0              300     mov P2, a
0169 75A000            301     mov P2,#0
                       302
016C 08                303     inc R0
016D E2                304     movx A,@R0
016E 75B004            305     mov P3, #00000100b
0171 F5A0              306     mov P2, a
0173 75A000            307     mov P2,#0
                       308
0176 08                309     inc R0
0177 E2                310     movx A,@R0
0178 75B008            311     mov P3, #00001000b
017B F5A0              312     mov P2, a
017D 75A000            313     mov P2,#0
                       314
0180 08                315     inc R0
0181 E2                316     movx A,@R0
0182 75B010            317     mov P3, #00010000b
0185 F5A0              318     mov P2, a
0187 75A000            319     mov P2,#0
                       320
018A 08                321     inc R0
018B E2                322     movx A,@R0
018C 75B020            323     mov P3, #00100000b
018F F5A0              324     mov P2, a
0191 75A000            325     mov P2,#0
                       326
0194 08                327     inc R0
0195 E2                328     movx A,@R0
0196 75B040            329     mov P3, #01000000b
0199 F5A0              330     mov P2, a
019B 75A000            331     mov P2,#0
                       332
019E 08                333     inc R0
019F E2                334     movx A,@R0
01A0 75B080            335     mov P3, #10000000b
01A3 F5A0              336     mov P2, a
01A5 75A000            337     mov P2,#0
                       338
01A8 E52A              339     mov A,42
                       340
01AA 22                341     ret
                       342
                       343     ; -----------------
                       344     ; Initialisieren der Zeichenfläche
                       345     ;------------------
                       346     initCanvas:
01AB 7800              347     MOV R0,#0;
01AD 75B001            348     MOV P3,#00000001
                       349
                       350
                       351     getNextRowInput:
                       352
                       353
                       354     waitForConfirmation:
01B0 E580              355     MOV A,P0;
01B2 5401              356     ANL A,#00000001b
01B4 70FA              357     jnz waitForConfirmation                 ;Warte bis P0.0 gedrückt wurde
                       358     waitForConfirmationButtonRelease:
01B6 E580              359     MOV A,P0;
01B8 5401              360     ANL A,#00000001b
01BA 60FA              361     jz waitForConfirmationButtonRelease     ;Warte bis P0.0 "Losgelassen" wurde
                       362
01BC E590              363     MOV A, P1               ;Zeile 0 in Akku
01BE F4                364     CPL A
01BF F2                365     movx @R0,A              ;Speichern
                       366
                       367     ;call display           ;Zeichnen
                       368
                       369
01C0 F5A0              370     mov P2, a
01C2 75A000            371     mov P2,#0
                       372
01C5 E5B0              373     mov a,P3
01C7 23                374     RL A
01C8 F5B0              375     mov p3,a
01CA 08                376     inc R0
                       377
01CB B808E2            378     cjne R0,#8,getNextRowInput;
                       379
01CE 22                380     ret
                       381
                       382     ; -----------------
                       383     ; Masken, sollten noch kombiniert werden ;)
                       384     ;------------------
01CF 8040201008        385     table: db 10000000b, 01000000b, 00100000b, 00010000b, 00001000b, 00000100b, 00000010b, 00000001b
     040201
01D7 0180402010        386     table2: db 00000001b, 10000000b, 01000000b, 00100000b, 00010000b, 00001000b, 00000100b, 00000010b, 00
     0804020180
                       387
                       388     end
ASSEMBLY COMPLETE, NO ERRORS FOUND, 1 WARNING


ERROR SUMMARY:
Line 21, WARNING:ThisORGhaslowervaluethanthepreviousone

SYMBOL TABLE:
??MCU_8051_IDE . . . . . . . . . . .  N  NUMB  8051H  NOT USED
??VERSION. . . . . . . . . . . . . .  N  NUMB  0149H  NOT USED
AC . . . . . . . . . . . . . . . . .  B  ADDR  00D6H  NOT USED
ACC. . . . . . . . . . . . . . . . .  D  ADDR  00E0H
ACSR . . . . . . . . . . . . . . . .  D  ADDR  0097H  NOT USED
ADCF . . . . . . . . . . . . . . . .  D  ADDR  00F6H  NOT USED
ADCLK. . . . . . . . . . . . . . . .  D  ADDR  00F2H  NOT USED
ADCON. . . . . . . . . . . . . . . .  D  ADDR  00F3H  NOT USED
ADDH . . . . . . . . . . . . . . . .  D  ADDR  00F5H  NOT USED
ADDL . . . . . . . . . . . . . . . .  D  ADDR  00F4H  NOT USED
AUXR . . . . . . . . . . . . . . . .  D  ADDR  008EH  NOT USED
AUXR1. . . . . . . . . . . . . . . .  D  ADDR  00A2H  NOT USED
B. . . . . . . . . . . . . . . . . .  D  ADDR  00F0H  NOT USED
BDRCON . . . . . . . . . . . . . . .  D  ADDR  009BH  NOT USED
BDRCON_1 . . . . . . . . . . . . . .  D  ADDR  009CH  NOT USED
BRL. . . . . . . . . . . . . . . . .  D  ADDR  009AH  NOT USED
CALCULATEMIDDLENEIGHBOURS. . . . . .  C  ADDR  0107H
CALCULATENEIGHBOURS. . . . . . . . .  C  ADDR  00FEH
CCAP0H . . . . . . . . . . . . . . .  D  ADDR  00FAH  NOT USED
CCAP0L . . . . . . . . . . . . . . .  D  ADDR  00EAH  NOT USED
CCAP1H . . . . . . . . . . . . . . .  D  ADDR  00FBH  NOT USED
CCAP1L . . . . . . . . . . . . . . .  D  ADDR  00EBH  NOT USED
CCAP2H . . . . . . . . . . . . . . .  D  ADDR  00FCH  NOT USED
CCAP3H . . . . . . . . . . . . . . .  D  ADDR  00FDH  NOT USED
CCAP4H . . . . . . . . . . . . . . .  D  ADDR  00FEH  NOT USED
CCAPL2H. . . . . . . . . . . . . . .  D  ADDR  00FCH  NOT USED
CCAPL2L. . . . . . . . . . . . . . .  D  ADDR  00ECH  NOT USED
CCAPL3H. . . . . . . . . . . . . . .  D  ADDR  00FDH  NOT USED
CCAPL3L. . . . . . . . . . . . . . .  D  ADDR  00EDH  NOT USED
CCAPL4H. . . . . . . . . . . . . . .  D  ADDR  00FEH  NOT USED
CCAPL4L. . . . . . . . . . . . . . .  D  ADDR  00EEH  NOT USED
CCAPM0 . . . . . . . . . . . . . . .  D  ADDR  00DAH  NOT USED
CCAPM1 . . . . . . . . . . . . . . .  D  ADDR  00DBH  NOT USED
CCAPM2 . . . . . . . . . . . . . . .  D  ADDR  00DCH  NOT USED
CCAPM3 . . . . . . . . . . . . . . .  D  ADDR  00DDH  NOT USED
CCAPM4 . . . . . . . . . . . . . . .  D  ADDR  00DEH  NOT USED
CCF0 . . . . . . . . . . . . . . . .  B  ADDR  00D8H  NOT USED
CCF1 . . . . . . . . . . . . . . . .  B  ADDR  00D9H  NOT USED
CCF2 . . . . . . . . . . . . . . . .  B  ADDR  00DAH  NOT USED
CCF3 . . . . . . . . . . . . . . . .  B  ADDR  00DBH  NOT USED
CCF4 . . . . . . . . . . . . . . . .  B  ADDR  00DCH  NOT USED
CCON . . . . . . . . . . . . . . . .  D  ADDR  00D8H  NOT USED
CFINT. . . . . . . . . . . . . . . .  C  ADDR  0033H  NOT USED
CH . . . . . . . . . . . . . . . . .  D  ADDR  00F9H  NOT USED
CHECKBOTTOM. . . . . . . . . . . . .  C  ADDR  00EFH
CHECKCOLUMN. . . . . . . . . . . . .  C  ADDR  009BH
CHECKEND . . . . . . . . . . . . . .  C  ADDR  00CBH
CHECKMID . . . . . . . . . . . . . .  C  ADDR  00EAH
CHECKMIDDLENEIGHBOUR . . . . . . . .  C  ADDR  0118H
CHECKPERFECTPOPULATION . . . . . . .  C  ADDR  00C0H
CHECKROW . . . . . . . . . . . . . .  C  ADDR  0095H
CHECKSIDENEIGHBOURS. . . . . . . . .  C  ADDR  010DH
CHECKTOP . . . . . . . . . . . . . .  C  ADDR  00DFH
CHECKUNDERPOPULATION . . . . . . . .  C  ADDR  00BBH
CKCON. . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CKCON0 . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CKRL . . . . . . . . . . . . . . . .  D  ADDR  0097H  NOT USED
CKSEL. . . . . . . . . . . . . . . .  D  ADDR  0085H  NOT USED
CL . . . . . . . . . . . . . . . . .  D  ADDR  00E9H  NOT USED
CLKREG . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CMOD . . . . . . . . . . . . . . . .  D  ADDR  00D9H  NOT USED
COPYNEWGENERATIONTOFIELD . . . . . .  C  ADDR  0124H
CPRL2. . . . . . . . . . . . . . . .  B  ADDR  00C8H  NOT USED
CR . . . . . . . . . . . . . . . . .  B  ADDR  00DEH  NOT USED
CT2. . . . . . . . . . . . . . . . .  B  ADDR  00C9H  NOT USED
CY . . . . . . . . . . . . . . . . .  B  ADDR  00D7H  NOT USED
DISPLAY. . . . . . . . . . . . . . .  C  ADDR  0155H
DP0H . . . . . . . . . . . . . . . .  D  ADDR  0083H  NOT USED
DP0L . . . . . . . . . . . . . . . .  D  ADDR  0082H  NOT USED
DP1H . . . . . . . . . . . . . . . .  D  ADDR  0085H  NOT USED
DP1L . . . . . . . . . . . . . . . .  D  ADDR  0084H  NOT USED
DPH. . . . . . . . . . . . . . . . .  D  ADDR  0083H  NOT USED
DPL. . . . . . . . . . . . . . . . .  D  ADDR  0082H  NOT USED
EA . . . . . . . . . . . . . . . . .  B  ADDR  00AFH  NOT USED
EC . . . . . . . . . . . . . . . . .  B  ADDR  00AEH  NOT USED
EECON. . . . . . . . . . . . . . . .  D  ADDR  0096H  NOT USED
ES . . . . . . . . . . . . . . . . .  B  ADDR  00ACH  NOT USED
ET0. . . . . . . . . . . . . . . . .  B  ADDR  00A9H  NOT USED
ET1. . . . . . . . . . . . . . . . .  B  ADDR  00ABH  NOT USED
ET2. . . . . . . . . . . . . . . . .  B  ADDR  00ADH  NOT USED
EX0. . . . . . . . . . . . . . . . .  B  ADDR  00A8H  NOT USED
EX1. . . . . . . . . . . . . . . . .  B  ADDR  00AAH  NOT USED
EXEN2. . . . . . . . . . . . . . . .  B  ADDR  00CBH  NOT USED
EXF2 . . . . . . . . . . . . . . . .  B  ADDR  00CEH  NOT USED
EXTI0. . . . . . . . . . . . . . . .  C  ADDR  0003H  NOT USED
EXTI1. . . . . . . . . . . . . . . .  C  ADDR  0013H  NOT USED
F0 . . . . . . . . . . . . . . . . .  B  ADDR  00D5H  NOT USED
FE . . . . . . . . . . . . . . . . .  B  ADDR  009FH  NOT USED
GETBOTTOMROW . . . . . . . . . . . .  C  ADDR  00F8H
GETNEXTROWINPUT. . . . . . . . . . .  C  ADDR  01B0H
GOTBOTTOMROW . . . . . . . . . . . .  C  ADDR  00FAH
GOTTOPROW. . . . . . . . . . . . . .  C  ADDR  00E6H
IE . . . . . . . . . . . . . . . . .  D  ADDR  00A8H
IE0. . . . . . . . . . . . . . . . .  B  ADDR  0089H  NOT USED
IE1. . . . . . . . . . . . . . . . .  B  ADDR  008BH  NOT USED
INCIFSET . . . . . . . . . . . . . .  C  ADDR  011EH
INIT . . . . . . . . . . . . . . . .  C  ADDR  0050H
INITCANVAS . . . . . . . . . . . . .  C  ADDR  01ABH
INT0 . . . . . . . . . . . . . . . .  B  ADDR  00B2H  NOT USED
INT1 . . . . . . . . . . . . . . . .  B  ADDR  00B3H  NOT USED
IP . . . . . . . . . . . . . . . . .  D  ADDR  00B8H  NOT USED
IPH. . . . . . . . . . . . . . . . .  D  ADDR  00B7H  NOT USED
IPH0 . . . . . . . . . . . . . . . .  D  ADDR  00B7H  NOT USED
IPH1 . . . . . . . . . . . . . . . .  D  ADDR  00B3H  NOT USED
IPL0 . . . . . . . . . . . . . . . .  D  ADDR  00B8H  NOT USED
IPL1 . . . . . . . . . . . . . . . .  D  ADDR  00B2H  NOT USED
IT0. . . . . . . . . . . . . . . . .  B  ADDR  0088H  NOT USED
IT1. . . . . . . . . . . . . . . . .  B  ADDR  008AH  NOT USED
KBE. . . . . . . . . . . . . . . . .  D  ADDR  009DH  NOT USED
KBF. . . . . . . . . . . . . . . . .  D  ADDR  009EH  NOT USED
KBLS . . . . . . . . . . . . . . . .  D  ADDR  009CH  NOT USED
MAIN . . . . . . . . . . . . . . . .  C  ADDR  0069H
NEW_GENERATION . . . . . . . . . . .  C  ADDR  0093H
OSCCON . . . . . . . . . . . . . . .  D  ADDR  0086H  NOT USED
OV . . . . . . . . . . . . . . . . .  B  ADDR  00D2H  NOT USED
P. . . . . . . . . . . . . . . . . .  B  ADDR  00D0H  NOT USED
P0 . . . . . . . . . . . . . . . . .  D  ADDR  0080H
P1 . . . . . . . . . . . . . . . . .  D  ADDR  0090H
P1M1 . . . . . . . . . . . . . . . .  D  ADDR  00D4H  NOT USED
P1M2 . . . . . . . . . . . . . . . .  D  ADDR  00E2H  NOT USED
P2 . . . . . . . . . . . . . . . . .  D  ADDR  00A0H
P3 . . . . . . . . . . . . . . . . .  D  ADDR  00B0H
P3M1 . . . . . . . . . . . . . . . .  D  ADDR  00D5H  NOT USED
P3M2 . . . . . . . . . . . . . . . .  D  ADDR  00E3H  NOT USED
P4 . . . . . . . . . . . . . . . . .  D  ADDR  00C0H  NOT USED
P4M1 . . . . . . . . . . . . . . . .  D  ADDR  00D6H  NOT USED
P4M2 . . . . . . . . . . . . . . . .  D  ADDR  00E4H  NOT USED
P5 . . . . . . . . . . . . . . . . .  D  ADDR  00E8H  NOT USED
PC . . . . . . . . . . . . . . . . .  B  ADDR  00BEH  NOT USED
PCON . . . . . . . . . . . . . . . .  D  ADDR  0087H  NOT USED
PPCL . . . . . . . . . . . . . . . .  B  ADDR  00BEH  NOT USED
PS . . . . . . . . . . . . . . . . .  B  ADDR  00BCH  NOT USED
PSL. . . . . . . . . . . . . . . . .  B  ADDR  00BCH  NOT USED
PSW. . . . . . . . . . . . . . . . .  D  ADDR  00D0H  NOT USED
PT0. . . . . . . . . . . . . . . . .  B  ADDR  00B9H  NOT USED
PT0L . . . . . . . . . . . . . . . .  B  ADDR  00B9H  NOT USED
PT1. . . . . . . . . . . . . . . . .  B  ADDR  00BBH  NOT USED
PT1L . . . . . . . . . . . . . . . .  B  ADDR  00BBH  NOT USED
PT2. . . . . . . . . . . . . . . . .  B  ADDR  00BDH  NOT USED
PT2L . . . . . . . . . . . . . . . .  B  ADDR  00BDH  NOT USED
PX0. . . . . . . . . . . . . . . . .  B  ADDR  00B8H  NOT USED
PX0L . . . . . . . . . . . . . . . .  B  ADDR  00B8H  NOT USED
PX1. . . . . . . . . . . . . . . . .  B  ADDR  00BAH  NOT USED
PX1L . . . . . . . . . . . . . . . .  B  ADDR  00BAH  NOT USED
RB8. . . . . . . . . . . . . . . . .  B  ADDR  009AH  NOT USED
RCAP2H . . . . . . . . . . . . . . .  D  ADDR  00CBH  NOT USED
RCAP2L . . . . . . . . . . . . . . .  D  ADDR  00CAH  NOT USED
RCLK . . . . . . . . . . . . . . . .  B  ADDR  00CDH  NOT USED
RD . . . . . . . . . . . . . . . . .  B  ADDR  00B7H  NOT USED
REN. . . . . . . . . . . . . . . . .  B  ADDR  009CH  NOT USED
RESET. . . . . . . . . . . . . . . .  C  ADDR  0000H  NOT USED
RI . . . . . . . . . . . . . . . . .  B  ADDR  0098H  NOT USED
RIGHTCHECKDONE . . . . . . . . . . .  C  ADDR  0123H
RS0. . . . . . . . . . . . . . . . .  B  ADDR  00D3H  NOT USED
RS1. . . . . . . . . . . . . . . . .  B  ADDR  00D4H  NOT USED
RXD. . . . . . . . . . . . . . . . .  B  ADDR  00B0H  NOT USED
SADDR. . . . . . . . . . . . . . . .  D  ADDR  00A9H  NOT USED
SADDR_0. . . . . . . . . . . . . . .  D  ADDR  00A9H  NOT USED
SADDR_1. . . . . . . . . . . . . . .  D  ADDR  00AAH  NOT USED
SADEN. . . . . . . . . . . . . . . .  D  ADDR  00B9H  NOT USED
SADEN_0. . . . . . . . . . . . . . .  D  ADDR  00B9H  NOT USED
SADEN_1. . . . . . . . . . . . . . .  D  ADDR  00BAH  NOT USED
SBUF . . . . . . . . . . . . . . . .  D  ADDR  0099H  NOT USED
SCON . . . . . . . . . . . . . . . .  D  ADDR  0098H  NOT USED
SETTIMER0. . . . . . . . . . . . . .  C  ADDR  0075H
SETTIMER1. . . . . . . . . . . . . .  C  ADDR  007EH
SINT . . . . . . . . . . . . . . . .  C  ADDR  0023H  NOT USED
SM0. . . . . . . . . . . . . . . . .  B  ADDR  009FH  NOT USED
SM1. . . . . . . . . . . . . . . . .  B  ADDR  009EH  NOT USED
SM2. . . . . . . . . . . . . . . . .  B  ADDR  009DH  NOT USED
SP . . . . . . . . . . . . . . . . .  D  ADDR  0081H  NOT USED
SPCON. . . . . . . . . . . . . . . .  D  ADDR  00C3H  NOT USED
SPCR . . . . . . . . . . . . . . . .  D  ADDR  00D5H  NOT USED
SPDAT. . . . . . . . . . . . . . . .  D  ADDR  00C5H  NOT USED
SPDR . . . . . . . . . . . . . . . .  D  ADDR  0086H  NOT USED
SPSR . . . . . . . . . . . . . . . .  D  ADDR  00AAH  NOT USED
SPSTA. . . . . . . . . . . . . . . .  D  ADDR  00C4H  NOT USED
T0 . . . . . . . . . . . . . . . . .  B  ADDR  00B4H  NOT USED
T1 . . . . . . . . . . . . . . . . .  B  ADDR  00B5H  NOT USED
T2CON. . . . . . . . . . . . . . . .  D  ADDR  00C8H  NOT USED
T2MOD. . . . . . . . . . . . . . . .  D  ADDR  00C9H  NOT USED
TABLE. . . . . . . . . . . . . . . .  C  ADDR  01CFH
TABLE2 . . . . . . . . . . . . . . .  C  ADDR  01D7H
TB8. . . . . . . . . . . . . . . . .  B  ADDR  009BH  NOT USED
TCLK . . . . . . . . . . . . . . . .  B  ADDR  00CCH  NOT USED
TCON . . . . . . . . . . . . . . . .  D  ADDR  0088H  NOT USED
TF0. . . . . . . . . . . . . . . . .  B  ADDR  008DH  NOT USED
TF1. . . . . . . . . . . . . . . . .  B  ADDR  008FH  NOT USED
TF2. . . . . . . . . . . . . . . . .  B  ADDR  00CFH  NOT USED
TH0. . . . . . . . . . . . . . . . .  D  ADDR  008CH
TH1. . . . . . . . . . . . . . . . .  D  ADDR  008DH
TH2. . . . . . . . . . . . . . . . .  D  ADDR  00CDH  NOT USED
TI . . . . . . . . . . . . . . . . .  B  ADDR  0099H  NOT USED
TIMER0 . . . . . . . . . . . . . . .  C  ADDR  000BH  NOT USED
TIMER0ROUTINE. . . . . . . . . . . .  C  ADDR  0087H
TIMER1 . . . . . . . . . . . . . . .  C  ADDR  001BH  NOT USED
TIMER2 . . . . . . . . . . . . . . .  C  ADDR  002BH  NOT USED
TL0. . . . . . . . . . . . . . . . .  D  ADDR  008AH
TL1. . . . . . . . . . . . . . . . .  D  ADDR  008BH
TL2. . . . . . . . . . . . . . . . .  D  ADDR  00CCH  NOT USED
TMOD . . . . . . . . . . . . . . . .  D  ADDR  0089H
TR0. . . . . . . . . . . . . . . . .  B  ADDR  008CH
TR1. . . . . . . . . . . . . . . . .  B  ADDR  008EH
TR2. . . . . . . . . . . . . . . . .  B  ADDR  00CAH  NOT USED
TXD. . . . . . . . . . . . . . . . .  B  ADDR  00B1H  NOT USED
WAITFORCONFIRMATION. . . . . . . . .  C  ADDR  01B0H
WAITFORCONFIRMATIONBUTTONRELEASE . .  C  ADDR  01B6H
WDTCON . . . . . . . . . . . . . . .  D  ADDR  00A7H  NOT USED
WDTPRG . . . . . . . . . . . . . . .  D  ADDR  00A7H  NOT USED
WDTRST . . . . . . . . . . . . . . .  D  ADDR  00A6H  NOT USED
WR . . . . . . . . . . . . . . . . .  B  ADDR  00B6H  NOT USED